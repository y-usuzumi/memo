# 有关派生

本文是以GHC 8.6.1为蓝本。参考了[http://downloads.haskell.org/~ghc/latest/docs/users_guide.pdf](http://downloads.haskell.org/~ghc/latest/docs/users_guide.pdf)中有关章节。

## 与派生 (deriving) 相关的扩展

Haskell 98允许在数据类型声明中加入派生语句来生成特定类型类 (class) 的标配实例。GHC从以下几个方面进行了扩展。

* 派生机制可以与类型声明分离 (`-XStandaloneDeriving`)
* 通过若干扩展可以派生除`Eq`、`Ord`、`Enum`、`Ix`、`Bounded`、`Read`和`Show`以外的类型类。
* 除了通过生成所有方法定义进行派生的标配方式之外，还支持两种GHC特殊的派生策略，可以对任意类型类派生出实例：
  * `-XGeneralizedNewtypeDeriving`
  * `-XDeriveAnyClass`

用户可以声明所需的派生策略，尤其是在编译器的默认选择是错误的情况下。当然也可以不加声明。

### 对空数据类型进行派生

_-XEmptyDataDeriving_ >= 8.4.1

允许为空类型派生出标准类型类的实例。

使用`-XEmptyDataDecls`可以定义无构造函数的数据类型。通过该扩展，可以为这些数据类型派生出类型类实例，比如：

```haskell
data Empty deriving (Eq, Ord, Read, Show)
```

派生出的代码如下：

```haskell
instance Eq Empty where
  _ == _ = True

instance Ord Empty where
  compare _ _ = EQ

instance Read Empty where
  readPrec = pfail
  
instance Show Empty where
  showsPrec _ x = case x of {}_
```

注意，该扩展只在派生上述四个标准类型类时才需要，使用其他扩展进行的派生操作不需要同时启用该扩展，包括：

* `-XStandaloneDeriving`
* 具有与自己一一对应的扩展的某些类型类，比如`-XDeriveFunctor`
* `-XDeriveAnyClass`

### 为派生语句推断的上下文

比如：

```haskell
data T0 f a = MkT0 a         deriving( Eq )
data T1 f a = MkT1 (f a)     deriving( Eq )
data T2 f a = MkT2 (f (f a)) deriving( Eq )
```

自然生成的`Eq`代码如下：

```haskell
instance Eq a         => Eq (T0 f a) where ...
instance Eq (f a)     => Eq (T1 f a) where ...
instance Eq (f (f a)) => Eq (T2 f a) where ...
```

T0完全OK，T1也还OK，但是T2不是Haskell 98标准，而且可能导致实例无法终止。

GHC采取了保守策略：接收前两个，拒绝第三个。规则如下：

* 在推断出的实例上下文中出现的约束 (Constraint)，仅包含类型变量，且类型变量最多出现一次。

该规则无视flag。如果你想要更变态的上下文，可以通过`-XStandaloneDeriving`自己写一个。
