# 异常处理

注：本文是对[Exceptions Best Practices in Haskell](https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell)的整理和思考。


## The IO contract

Haskell的社区中流传的一个常见的观点是：异常应该显式地指定在类型中；异步异常是辣鸡。

然而通过GHC的实现我们可以看出它的立场：

* IO中可以抛出任何类型的异常，只要是Exception的实例。
* GHC支持异步异常。

我们假定GHC的思路是正确的，这不为过吧？

请默默地认同如下观点：

* IO中的任何代码都可以抛出运行时异常。
* 可以通过异步异常在任何时间任何地点杀掉任何线程。


## 各种辣鸡反模式

### ExceptT IO

形如下面的代码：

```haskell
myFunction :: String -> ExceptT MyException IO Int
```

至少有三个猫饼：

1. 无法组合。如果别人有个不同的异常类型`HisException`，就不能简单地组合。
1. 它给人造成一个假象：这个函数里只会抛出`MyException`类型的异常。其实任何IO操作都可以
   抛出不同类型的异常，甚至是异步异常。
1. 并没有限制住异常的种类，而是提供了另一种抛出异常的方式，既可以`throwE`，又可以`liftIO . throwIO`。

所以，用`ExceptT`/`EitherT`/`ErrorT`来套`IO`几乎永远是错误的。

另外，在公共API中提供具体类型的monad transformer也几乎永远是错误的。最好是提供基于mtl和
类型类的抽象类型。

还有一种长得差不多的：

```haskell
myFunction :: String -> ExceptT Text IO Int
```

编码者觉得以后`Text`可能会改成其他的异常类型，比如`MyException`，然而，很大可能性你这个`Text`会留一辈子，因为它刚好避免了之前提到的组合问题。然而用非结构化的`Text`来表达有用的错误类型信息你不觉得很213么。

解决办法是：尽量返回`Either`，对于少见的错误才抛出异常。

另外要提到一点，`ExceptT`和非IO-base的monad组合没有任何问题。


### Mask-them-all

这种反模式的背景是：在每个地方处理异步异常是处理不过来/不干净的，干脆隐藏掉算了。

异步异常是很烦，但却是保证系统稳定可靠运行的关键。

就算很烦，你也要处理。

掌握以下几个最佳实践：

* [Bracket模式](https://wiki.haskell.org/Bracket_pattern)
* [safe-exceptions包](http://hackage.haskell.org/package/safe-exceptions)
* 如果你的控制流极其复杂，或者使用non-linear scoping of resources (这特么是啥意思)，使用[resourcet](https://hackage.haskell.org/package/resourcet)


## 最佳方案

### MonadThrow

考虑以下代码：

```haskell
foo <- lookup "foo" m
bar <- lookup "bar" m
baz <- lookup "baz" m
f foo bar baz
```

如果这个函数返回`Nothing`，我们根本不知道是哪里出问题，可能是如下原因之一：

1. "foo"不在map里
1. "bar"不在map里
1. "baz"不在map里
1. `f`函数返回了`Nothing`

所以`Maybe`返回类型会导致丢失很多有用信息。再比较下面的代码：

```haskell
lookup :: Eq k => k -> [(k, v)] -> Either (KeyNotFound k) v

f :: SomeVal -> SomeVal -> SomeVal -> Either F'sExceptionType F'sResult
```

这样我们需要的信息就都保留了。然而新的问题来了：这两个函数没法组合。

这时候你就需要思考：我到底要不要这些信息？如果不需要，用`Maybe`就可以了，否则，
请使用`exceptions`包中的`MonadThrow`：

```haskell
lookup :: (MonadThrow m, Eq k) => k -> [(k, v)] -> m v

f :: MonadThrow m => SomeVal -> SomeVal -> SomeVal -> m F'sResult
```

和`Either`版本相比，我们丢失了错误类型信息，相应地，我们得到了与`Maybe`（以及其他`MonadThrow`实例）的可组合性和一致性。

`MonadThrow`是一个折衷方案，但它是经过作者深思熟虑的，也和Haskell的运行时异常保持了一致，都不会捕捉异常类型信息。


### Transformers

下面的类型签名约束太强：

```haskell
foo :: Int -> IO String
```

可以泛化为：

```haskell
foo :: MonadIO m => Int -> m String
```

再借助`liftIO`来使用。

这可以让函数与任何IO-base的transformer组合使用。

然而，如果有个函数长这样：

```haskell
bar :: FilePath -> (Handle -> IO a) -> IO a
```

如果你想把这个函数参数放在一个IO-base的transformer中，你会发现很难搞。可以使用`lift-base`，但是很复杂。
你可以使用`safe-exceptions`库得到这种更为泛化的类型：

```haskell
bar :: (MonadIO m, MonadMask m) => FilePath -> (Handle -> m a) -> m a
```

不止可以用于异常处理，还可以用于创建线程之类。另外可以考虑一下使用`resourcet`库中的`Acquire`类型。


### 自定义异常类型

这是一种很213的实践：

```haskell
foo = do
    if x then return y else error "something bad happened"
```

这让调用者的处理变得很困难。相比之下，你应该定义一个异常类型：

```haskell
data SomethingBad = SomethingBad
    deriving Typeable
instance Show SomethingBad where
    show SomethingBad = "something bad happened"
instance Exception SomethingBad
foo = do
    if x then return y else throwM SomethingBad
```

虽然有很多样板代码，但是带来了很多好处。

现在给调用者抓`SomethingBad`就很容易了。另外，通过使用`throwM`，代码执行顺序也可以得到充分保证，
而不像使用`error`，它只会创建一个pure值异常，只有对异常求值的时候才会抛出来。
