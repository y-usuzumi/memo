# 异常处理

注：本文是对[Exceptions Best Practices in Haskell](https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell)的整理和思考。

## The IO contract

Haskell的社区中流传的一个常见的观点是：异常应该显式地指定在类型中；异步异常是辣鸡。

然而通过GHC的实现我们可以看出它的立场：

* IO中可以抛出任何类型的异常，只要是Exception的实例。
* GHC支持异步异常。

我们假定GHC的思路是正确的，这不为过吧？

请默默地认同如下观点：

* IO中的任何代码都可以抛出运行时异常。
* 可以通过异步异常在任何时间任何地点杀掉任何线程。


## 各种辣鸡反模式

### ExceptT IO

形如下面的代码：

```haskell
myFunction :: String -> ExceptT MyException IO Int
```

至少有三个猫饼：

1. 无法复合。如果别人有个不同的异常类型`HisException`，就不能简单地复合。
1. 它给人造成一个假象：这个函数里只会抛出`MyException`类型的异常。其实任何IO操作都可以
   抛出不同类型的异常，甚至是异步异常。
1. 并没有限制住异常的种类，而是提供了另一种抛出异常的方式，既可以`throwE`，又可以`liftIO . throwIO`。

所以，用ExceptT/EitherT/ErrorT来套IO几乎永远是错误的。

另外，在公共API中提供具体类型的monad transformer也几乎永远是错误的。最好是提供基于mtl和
类型类的抽象类型。

还有一种长得差不多的：

```haskell
myFunction :: String -> ExceptT Text IO Int
```

编码者觉得以后`Text`可能会改成其他的异常类型，比如`MyException`，然而，很大可能性你这个`Text`会留一辈子，因为它刚好避免了之前提到的复合问题。然而用非结构化的`Text`来表达有用的错误类型信息你不觉得很213么。

解决办法是：尽量返回Either，对于少见的错误才抛出异常。

另外要提到一点，ExceptT和非IO-base的monad组合没有任何问题。

### Mask-them-all

这种反模式的背景是：在每个地方处理异步异常是处理不过来/不干净的，干脆隐藏掉算了。

异步异常是很烦，但却是保证系统稳定可靠运行的关键。

就算很烦，你也要处理。

掌握以下几个最佳实践：

* [Bracket模式](https://wiki.haskell.org/Bracket_pattern)
* [safe-exceptions包](http://hackage.haskell.org/package/safe-exceptions)
* 如果你的控制流极其复杂，或者使用non-linear scoping of resources (这特么是啥意思)，使用[resourcet](https://hackage.haskell.org/package/resourcet)
