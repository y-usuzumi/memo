# 异常处理

注：本文是对[Exceptions Best Practices in Haskell](https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell)的整理和思考。

## The IO contract

Haskell的社区中流传的一个常见的观点是：异常应该显式地指定在类型中；异步异常是辣鸡。

然而通过GHC的实现我们可以看出它的立场：

* IO中可以抛出任何类型的异常，只要是Exception的实例。
* GHC支持异步异常。

我们假定GHC的思路是正确的，这不为过吧？

请默默地认同如下观点：

* IO中的任何代码都可以抛出运行时异常。
* 可以通过异步异常在任何时间任何地点杀掉任何线程。


## 各种辣鸡反模式

### ExceptT IO

形如下面的代码：

```haskell
myFunction :: String -> ExceptT MyException IO Int
```

至少有三个猫饼：

1. 无法复合。如果别人有个不同的异常类型`HisException`，就不能简单地复合。
1. 它给人造成一个假象：这个函数里只会抛出`MyException`类型的异常。其实任何IO操作都可以
   抛出不同类型的异常，甚至是异步异常。
1. 并没有限制住异常的种类，而是提供了另一种抛出异常的方式，既可以`throwE`，又可以`liftIO . throwIO`。

所以，用ExceptT/EitherT/ErrorT来套IO几乎永远是错误的。

另外，在公共API中提供具体类型的monad transformer也几乎永远是错误的。最好是提供基于mtl和
类型类的抽象类型。