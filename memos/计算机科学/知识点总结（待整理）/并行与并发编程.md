# 并行与并发编程

## 三个问题

1. 原子性问题
1. 可见性问题

   ```java
   // Thread 1
   int i = 0;
   i = 10;

   // Thread 2
   j = i;  // 线程1将i加载到调整缓存，然后赋值为10,却不一定立即写回主存。
           // 此时线程2从主存中读取i，结果为0。
   ```

1. 有序性问题

    ```java
    int i = 0;
    boolean flag = false;

    i = 1;
    flag = true;

    // 由于i和flag互不相干，可能在JVM中发生指令重排序（Dynamic
    // execution / Out-of-order execution）。
    ```

    ```java
    //线程1:
    context = loadContext();   //语句1
    inited = true;             //语句2

    //线程2:
    while(!inited) {
        sleep();
    }
    doSomethingwithconfig(context);

    // 线程1中的指令可能发生重排序，此时在线程2看来，有可能在inited已经置为true
    // 的情况下，loadContext仍然未被调用。
    ```

    Java的`volatile`关键字保证了**可见性**。

## Go

### Goroutine的调度原理

M:N

多个goroutine被调度到任意多个系统线程上。


## 高并发

### 限流问题

限流的常用处理手段：

* 计数器（也就是固定窗口）
* 滑动窗口
* 漏桶
* 令牌桶

#### 计数器

在每个时间单位开始时，比如每分钟的0秒，计数器归0。

问题：存在时间临界点的问题，比如前59秒都没有请求，结果到最后一秒突然出现100个请求，以及在下一秒刚开始的时候又出现100个请求，可能系统就不行了。

#### 滑动窗口

窗口滑动的时候滑出去的部分从计数器中减掉。以上面计数器算法中遇到的问题为例，
假如把一秒拆分为4个小窗口，那在下一秒开始之初，统计的是前一秒的后750ms以及下一秒的前250ms，因此下一秒初接受的请求数量仍然受限。

问题：仍然有时间片的概念，所以理论上仍然有可能出现计数器相同的问题，只是更为缓解。

#### 漏桶

一个桶，出水量恒定（每时间片减去出水量），每次请求相当于加一滴水，如果满了就拒绝服务。

然而在网络流量整形中，漏桶用于提供恒定的最大流量，与API请求限制方法中漏桶的使用有区别。

#### 令牌桶

一个桶，有一个令牌生成器不断往桶里添加令牌，生成速度是恒定的，多余的令牌扔掉。请求不到令牌就拒绝服务。
