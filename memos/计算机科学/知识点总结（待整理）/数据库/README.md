# 数据库

[https://www.youtube.com/watch?v=aZjYr87r1b8](https://www.youtube.com/watch?v=aZjYr87r1b8)

## 索引的原理

假设一个block有512字节。

假设数据表中一条记录占据128个字节，那么每个block可以存储512/128 = 4条记录。

### 单级索引

其中ID字段10个字节，指针6个字节，也就是每条索引16个字节，那么每个block可以存储512/16 = 32条索引。
如果一共有100条记录，那么存储数据需要100 / 4 = 25个block；存储索引需要100 / 32 = 3.125 (ceil到4) 个block。

此时找一条记录最多可能需要访问4个索引block + 1个指针所指向的数据block = 5个block。

单级索引是密集索引，因为每条索引都对应一条记录。

### 多级索引

如果一共有1000条记录，此时索引记录需要占据1000 / 32 = 31.25 (ceil到32) 个block，那么此时
找一条记录最多可能需要访问32 + 1 = 33个block。

通过多级索引，可以减少访问的block数：

设置一个多级索引，其中每条记录指向下级索引所占据的block，由于一个block存储32个下级索引，那么
可以通过多级索引中的第一条查找到第1~32条记录，而下一条多级索引则对应第33~64条记录。
一共需要32 个下级索引block / 每block存储32个索引块指针 = 1个block。

此时找一条记录最多可能访问1个上级索引block + 1个下级索引block + 1个数据block = 3个block。

依此类推，可以有任意多级索引。

多级索引是稀疏索引，因为每条索引对应不止一条记录。

### M-way Search Tree

M叉查找树。相比二叉查找树，每个节点可以有 **最多** M-1个key和M个儿子。
M为M叉查找树的度。相应地，二叉查找树的度为2。
（顺便复习一下，节点的度就是节点的儿子的个数）

```
/------------------\
| . 10 . 20 . 30 . |
\-|----|----|----|_/
  |    |    |    +------(30<key)
  |    |    +-----------(20<key<30)
  |    +----------------(10<key<20)
  +---------------------(key<10)
```

```
--------------------------------
| p | k1 | p | k2 | p | k3 | p |
--------------------------------
```

如何用M叉查找树表示多级索引？

```
-----------------------------------------------
| p | k1 | rp | p | k2 | rp | p | k3 | rp | p |
-----------------------------------------------
```

其中，p是子节点指针，k1~k3是key，rp是记录指针。
其实并不存在索引的索引，只不过索引本身具备树形结构从而具有了多级索引的高效查找能力。

### B-Tree

M叉查找树本身并没有定义插入数据的规则，你可以完全不考虑树的平衡，从而构建一个近乎线性表的M叉树。
这对于查找操作是十分不利的。其实B-Tree就是M叉查找树加几个规则：

1. 如果是M叉查找树，那每节点至少要填满ceil(M/2)个key之后才考虑创建子节点。
1. 如果根节点不是叶子，它最少得有2个儿子。
1. 所有的叶子节点都得在同一层。
1. 创建过程是自底向上进行的。

举例：

构建4叉B-tree，进行如下过程：

第一、二、三步，插入10、20、40：

```
--------------------
| . 10 . 20 . 40 . |
--------------------
```

第四步，插入50：

此时根节点已经放不下了，要拆分：

```
----------
| . 40 . |
--|----|--    ----------
  |    +------| . 50 . |
  |           ----------
  |           ---------------
  +-----------| . 10 . 20 . |
              ---------------
```

这样能确保根节点有两个儿子，并且叶子节点都在同一层，而且构建过程是向上的（先拆分，再创建上层节点）。

第五、六步，插入60、70：

```
----------
| . 40 . |
--|----|--    --------------------
  |    +------| . 50 . 60 . 70 . |
  |           --------------------
  |           ---------------
  +-----------| . 10 . 20 . |
              ---------------
```

第七步，插入80：

又需要拆分了：

```
---------------
| . 40 . 70 . |
--|----|----|--    ----------
  |    |    +------| . 80 . |
  |    |           ----------
  |    |           ---------------
  |    +-----------| . 50 . 60 . |
  |                ---------------
  |                ---------------
  +----------------| . 10 . 20 . |
                   ---------------
```

第八步，插入30：

```
---------------
| . 40 . 70 . |
--|----|----|--    ----------
  |    |    +------| . 80 . |
  |    |           ----------
  |    |           ---------------
  |    +-----------| . 50 . 60 . |
  |                ---------------
  |                --------------------
  +----------------| . 10 . 20 . 30 . |
                   --------------------
```

第九步，插入35：

```
--------------------
| . 30 . 40 . 70 . |
--|----|----|----|--    ----------
  |    |    |    +------| . 80 . |
  |    |    |           ----------
  |    |    |           ---------------
  |    |    +-----------| . 50 . 60 . |
  |    |                ---------------
  |    |                ----------
  |    +----------------| . 35 . |
  |                     ----------
  |                     ---------------
  +---------------------| . 10 . 20 . |
                        ---------------
```

第十步，插入5：

```
--------------------
| . 30 . 40 . 70 . |
--|----|----|----|--    ----------
  |    |    |    +------| . 80 . |
  |    |    |           ----------
  |    |    |           ---------------
  |    |    +-----------| . 50 . 60 . |
  |    |                ---------------
  |    |                ----------
  |    +----------------| . 35 . |
  |                     ----------
  |                     -------------------
  +---------------------| . 5 . 10 . 20 . |
                        -------------------
```

第十一步，插入15：

```
-------------------------
| . 15 . 30 . 40 . 70 . |  # 根节点冒了，还需要递归地创建上层。
--|----|----|----|----|--         ----------
  |    |    |    |    +-----------| . 80 . |
  |    |    |    |                ----------
  |    |    |    |                ---------------
  |    |    |    +----------------| . 50 . 60 . |
  |    |    |                     ---------------
  |    |    |                     ----------
  |    |    +---------------------| . 35 . |
  |    |                          ----------
  |    |                          ----------
  |    +--------------------------| . 20 . |
  |                               ----------
  |                               --------------
  +-------------------------------| . 5 . 10 . |
                                  --------------
```

根节点冒了，还需要递归地创建上层：

```
----------
| . 40 . |
--|----|--       ----------
  |    +---------| . 70 . |
  |              --|----|--     ----------
  |                |    +-------| . 80 . |
  |                |            ----------
  |                |            ---------------
  |                +------------| . 50 . 60 . |
  |                             ---------------
  |
  |              ---------------
  +--------------| . 15 . 30 . |
                 --|----|----|--    ----------
                   |    |    +------| . 35 . |
                   |    |           ----------
                   |    |           ----------
                   |    +-----------| . 20 . |
                   |                ----------
                   |                --------------
                   +----------------| . 5 . 10 . |
                                    --------------
```

DONE!

### B+ Tree

相比上面的B-Tree，区别有两点：

1. 所有的非叶子节点上的key在其最下方的叶子节点上都有复本。
1. 所有的rp指针都只在叶子节点上。
1. 叶子节点之间形成链表。

上面的B-Tree表示为B+ Tree如下（链表部分就不表示了）：

```
----------
| . 40 . |
--|----|--       ----------
  |    +---------| . 70 . |
  |              --|----|--     ---------------
  |                |    +-------| . 70 . 80 . |
  |                |            ---------------
  |                |            -------------------
  |                +------------| . 40 . 50 . 60 . |
  |                             --------------------
  |
  |              ---------------
  +--------------| . 15 . 30 . |
                 --|----|----|--    ---------------
                   |    |    +------| . 30 . 35 . |
                   |    |           ---------------
                   |    |           ---------------
                   |    +-----------| . 15 . 20 . |
                   |                ---------------
                   |                --------------
                   +----------------| . 5 . 10 . |
                                    --------------
```

现在叶子层构成了密集索引。所以B+ Tree比B-Tree更像是多层索引。

叶子节点形成的链表，想象中可以帮助更快地进行范围查询。

> Q: 为什么B+ Tree比B-Tree更适合用作外存索引？
> A: 由于在B+ Tree中，rp指针仅存在叶子节点上，因此，当以页为单位存储索引时，中间层可以包含更大的出度，存储更多的指针，从而导致树的整体深度进一步降低。

### Clustered index和 Non-clustered index

Non-clustered index是脱离于实际数据存在的单独存放的索引。

Clustered
