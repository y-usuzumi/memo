# 树

## AVL树

一种平衡二叉查找树。

### 平衡因子 (balance factor)

左子树的高度-右子树的高度 = {-1, 0, 1}

### LL-imbalance和LL-rotation

从下树开始：

```
  30(1)
 /
20(0)
```

插入10：

```
    30(2)
   /
  20(1)
 /
10(0)
```

在左子树中插入左侧节点，导致不平衡，此为LL-imbalance（左侧重），因此使用右旋转 (LL-rotation)，步骤略。

### LR-imbalance和LR-rotation

从下树开始：

```
  30(1)
 /
10(0)
```

插入10：

```
    30(2)
   /
  10(-1)
    \
     20(0)
```

此为LR-imbalance，使用左右旋转 (LR-rotation)，步骤如下：

1. 以10为根左旋转。
1. 以30为根右旋转。

### RR-imbalance和RR-rotation

和LL-imbalance和LL-rotation相反。

### RL-imbalance和RL-rotation

和LR-imbalance和LR-rotation相反。

### 注意事项

* 我们只看插入操作从不平衡节点往下算起的前两个方向，比如LRLR-imbalance，其实相当于LR-imbalance。

## 红黑树

一种平衡二叉查找树。

特点：

1. 节点要么是红的，要么是黑的。
1. 根节点和叶子节点 (NIL) 是黑的。
1. 如果节点是红的，那他的儿子们都是黑的。
1. 从一个节点出发到它下面所有的叶子节点经过的路径，都包含相同数量的黑节点。

其他特点：

* 节点需要一个bit来存储颜色信息。
* 最长路径（从根节点到最远的叶子节点）不会超过最短路径（从根节点到最近的叶子节点）长度的两倍。
  * 最短路径仅包括黑节点
  * 最长路径包括交替出现的红黑节点

属性：

* 黑高度：从某节点出发到任一个叶子节点经历的黑节点的数目（不包括自己）。

支持的操作：

* 查找 O(log n)
* 插入 O(log n)（需要旋转）
* 删除 O(log n)（需要旋转）

空间复杂度：O(n)

### 插入策略

1. 插入Z，涂上红色
1. 重新涂色和旋转节点来解决违反规则

具体来说：
1. 当Z为根节点时，把它标为黑色
1. 当Z的叔叔为红色时，重新上色
1. 当Z的叔叔为黑色（三角形），旋转Z的爸爸
1. 当Z的叔叔为黑色（线形），旋转Z的爷爷，重新上色

**TODO**
